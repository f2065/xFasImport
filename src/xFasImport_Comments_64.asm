




proc import_sources_to_comments
locals
 filename_src_compare rq 1
 MemSrcFile rq 1
 SizeSrcFile rq 1
 prev_assembly_dump_item rq 1
 position_line_in_source rq 1
 flag_skip_export_TEXT rq 1
 AddrInfo_address rq 1
 buffer_comment sized db MAX_COMMENT_SIZE+8 dup (?)
 buffer_label sized db MAX_LABEL_SIZE+8 dup (?)
 text_buff_temp sized dw MAX_COMMENT_SIZE+500 dup (?)
 tab_pos1 rq 1
 tab_pos2 rq 1
 tab_pos3 rq 1
 tab_pos4 rq 1
 tab_pos5 rq 1
endl

	push	rsi
	push	rdi
	push	rbx
	push	r12 ; stack align

	xor	eax, eax
	mov	[filename_src_compare], rax
	mov	[prev_assembly_dump_item], rax
	mov	[MemSrcFile], rax
	mov	[SizeSrcFile], rax

	mov	rsi, [address_preprocessed_source]

	; ESI - real address of preprocessed source.

.main_loop:
	mov	[flag_skip_export_TEXT], 0
	cmp	rsi, [endOf_preprocessed_source] ; ESI = real addr of preprocessed source.
	jae	.end_main_loop

	test	byte [rsi+preprocessed_line.number_line+3], 0x80 ; If bit31=0 = line was loaded from source, If bit31=1 = line was generated by macroinstruction.
	jnz	.skip_line ; line by macroinstruction

	mov	ebx, [rsi+preprocessed_line.offset_prep_line_in_macro_def] ; !!! current real addr of asm dump !!! stored in prepare_asmdumps_offsets
	test	ebx, ebx
	jz	.skip_line2
	; differences in 32 and 64 plugin versions: 32 - store real addr, 64 - store offset (it is not possible to put the QWORD address in DWORD)
	add	rbx, [address_assembly_dump]
	
	test	byte [rbx+assembly_dump.flags], 3 
	; b0 set = then at this point the assembly was taking place inside the virtual block, and the offset in output file has no meaning here.
	; b1 set = the line was assembled at the point, which was not included in the output file for some other reasons (like inside the reserved data at the end of section).
	jnz	.skip_line2

	mov	r12, rsi ; ESI = real addr of preprocessed source.
	mov	edx, [rsi+preprocessed_line.offset_file_name]
	mov	ecx, [rsi+preprocessed_line.number_line]

.loop_skip_dublicate1: ; ESI = real addr of preprocessed source
	stdcall	get_next_preprocessed_source_item, rsi
	mov	rsi, rax
	cmp	rsi, [endOf_preprocessed_source]
	jae	.end_loop1

	cmp	edx, [rsi+preprocessed_line.offset_file_name] ; cmp with the previous item
	jne	.different_file
	cmp	ecx, [rsi+preprocessed_line.number_line]
	jz	.loop_skip_dublicate1
.different_file:
	test	byte [rsi+preprocessed_line.number_line+3], 0x80 ; If highest bit 0 = line loaded from source. If highest bit 1 = line generated by macroinstruction.
	jnz	.loop_skip_dublicate1 ; JMP - line by macroinstruction

	mov	eax, [rsi+preprocessed_line.offset_prep_line_in_macro_def] ; !!! current real addr of asm dump !!! stored in prepare_asmdumps_offsets
	test	eax, eax
	jz	.loop_skip_dublicate1
	; differences in 32 and 64 plugin versions: 32 - store real addr, 64 - store offset (it is not possible to put the QWORD address in DWORD)
	add	rax, [address_assembly_dump]

	test	byte [rax+assembly_dump.flags], 3
	; b0 set = then at this point the assembly was taking place inside the virtual block, and the offset in output file has no meaning here.
	; b1 set = the line was assembled at the point, which was not included in the output file for some other reasons (like inside the reserved data at the end of section).
	jnz	.loop_skip_dublicate1

	mov	eax, [rax] ; result: EAX =  tab4 [+0] Offset in output file.
	jmp	.exit_loop1

.end_loop1:
	mov	rax, [size_exe_by_fas]

.exit_loop1:
	mov	rsi, r12 ; pop ESI = real addr of preprocessed source (current item).
	mov	edx, [rbx] ; EBX = current real addr of asm dump, EDX = +0 | dword | Offset in output file.
	sub	rax, rdx
	jbe	.skip_line2

;ESI = real addr of preprocessed source (current item).
;EBX = current offset (real addr) of asm dump

	call	.get_address_value
	jmp	.part2

.skip_line2:
	mov	[flag_skip_export_TEXT], 1


.part2:
	mov	edx, [rsi+preprocessed_line.offset_file_name]
	; Table 3  Preprocessed line
	; +0 (dword) When the line was loaded from source, this field contains either zero (if it is the line from the main input file), 
	; or an offset inside the preprocessed source to the name of file, from which this line was loaded (the name of file is zero-ended string).
	; When the line was generated by macroinstruction, this field contains offset inside the preprocessed source to the pascal-style string specifying
	; the name of macroinstruction, which generated this line.
	test	edx, edx
	jz	.load_main_srcfile
	add	rdx, [address_preprocessed_source]
	jmp	.cmp_already_loaded
.load_main_srcfile:
	mov	rdx, [address_input_file_name]
.cmp_already_loaded:
	cmp	rdx, [filename_src_compare]
	je	.skip_load_file ; this file has already been loaded

	mov	[filename_src_compare], rdx ; store for comparison in next lines

	mov	rcx, [MemSrcFile]
	test	rcx, rcx
	jz	@f
	invoke	LocalFree, rcx
	mov	[MemSrcFile], 0
	@@:

	stdcall	load_basepath_fileA_to_mem, [filename_src_compare] ; return - eax hMemory, edx size, ecx timecode. eax=0 - error
	test	rax, rax
	jz	.sstc_exit
	mov	[MemSrcFile], rax
	mov	[SizeSrcFile], rdx

	mov	rax, [timeFasFile] ; ASM-file must be written before FAS-file.
	cmp	rax, rcx
	jae	.time_ok
	or	[incorrect_time_flag], 2
	.time_ok:

.skip_load_file:


	mov	rax, [MemSrcFile]
	mov	r8d, [rsi+preprocessed_line.position_file]
	add	rax, r8
	; table3: +8 = If the line was loaded from source, this field contains the position of the line inside the source file, from which it was loaded.
	; If line was generated by macroinstruction, this field contains the offset of preprocessed line, which invoked the macroinstruction.
	; If line was generated by instantaneous macro, this field is equal to the next one.
	mov	[position_line_in_source], rax

	cmp	[flag_skip_export_TEXT], 0
	jnz	.skip_line

	call	.get_comment_value
	cmp	[flag_skip_export_TEXT], 0
	jnz	.skip_line
	lea	rdx, [buffer_comment]
	cmp	[config_flag_comments_manual], 0
	je	.setA
	cinvoke	DbgSetCommentAt, [AddrInfo_address], rdx
	jmp	.setZ
.setA:	cinvoke	DbgSetAutoCommentAt, [AddrInfo_address], rdx
.setZ:
	inc	[imported_comments_counter]


;
.skip_line: ; ESI = real addr of preprocessed source
	mov	edx, [rsi+preprocessed_line.offset_file_name] 
	mov	ecx, [rsi+preprocessed_line.number_line]

.loop_skip_dublicate2: ; ESI = real addr of preprocessed source
	stdcall	get_next_preprocessed_source_item, rsi
	mov	rsi, rax
	cmp	edx, [rsi+preprocessed_line.offset_file_name]
	jne	.main_loop
	cmp	ecx, [rsi+preprocessed_line.number_line]
	jne	.main_loop
	jmp	.loop_skip_dublicate2



.end_main_loop:

frame
	lea	rsi, [text_buff_temp]
	cinvoke	wnsprintfW, rsi, (sizeof.text_buff_temp)/2, [msg_comments_loaded_U], [imported_comments_counter]
	stdcall	LogPrintW, rsi
endf

	xor	eax, eax
	inc	eax
.sstc_exit:
	pop	r12
	pop	rbx
	pop	rdi
	pop	rsi
	ret




;---------------------------------

; ret: EAX = addr, flag_skip_export_TEXT=1 if skip
.get_address_value:

	mov	eax, [rsi+preprocessed_line.offset_prep_line_in_macro_def] ; !!! current real addr of asm dump !!! stored in prepare_asmdumps_offsets
	test	eax, eax ; eax = Table 4 Row of the assembly dump
	jz	.gav_skip
	; differences in 32 and 64 plugin versions: 32 - store real addr, 64 - store offset (it is not possible to put the QWORD address in DWORD)
	add	rax, [address_assembly_dump]

	cmp	[prev_assembly_dump_item], 0
	jz	.gav_first_item

	push	rsi
	push	rdi
	cld
	lea	rsi, [rax+assembly_dump.address] ; +8 (qword) Value of $ address.
	mov	rdi, [prev_assembly_dump_item]
	mov	ecx, 0x11 ; compare bytes: 8-24 (last byte +24 - Type of $ address value)
	repe	cmpsb
	pop	rdi
	pop	rsi
	je	.gav_skip ; JMP if [esi]==[edi]

.gav_first_item: ; !!! ESI+0x0C = current offset (real addr) of asm dump
	mov	ebx, [rsi+preprocessed_line.offset_prep_line_in_macro_def] ; !!! current real addr of asm dump !!! stored in prepare_asmdumps_offsets
	; differences in 32 and 64 plugin versions: 32 - store real addr, 64 - store offset (it is not possible to put the QWORD address in DWORD)
	add	rbx, [address_assembly_dump]
	cmp	dword [rbx+assembly_dump.address], 0 ; +8 (qword) Value of $ address.
	je	.gav_skip
	cmp	dword [rbx+assembly_dump.address+4], 0 ; +8 (qword) Value of $ address.
	jne	.gav_skip ; only for 32-bit plugin
	cmp	byte [rbx+assembly_dump.address_higher_bits], 0 ; tab4  +27 (byte) The higher bits of value of $ address.
	jnz	.gav_skip

	lea	rax, [rbx+assembly_dump.address]
	mov	[prev_assembly_dump_item], rax
 
	mov	edx, [rbx+assembly_dump.info_external_symbol]
	; If the $ address is relocatable, this field contains information about section or external symbol, to which it is relative - otherwise this field is zero.
	; When the highest bit is cleared, the address is relative to a section, and the bits 0-30 contain the index (starting from 1) in the table of sections.
	; When the highest bit is set, the address is relativeto an external symbol, and the bits 0-30 contain the the offset of the name of this symbol in the strings table.
	test	edx, edx
	jnz	.gav_skip

	cmp	dword [rbx+assembly_dump.sib], 0 ; Extended SIB for the $ address
	jnz	.gav_skip

	mov	rdx, qword [rbx+assembly_dump.address]
	sub	rdx, [original_base_addr]
	add	rdx, [current_base_addr]
	mov	[AddrInfo_address], rdx

	retn

.gav_skip:
	mov	[flag_skip_export_TEXT], 1
	retn
	

;----------------------------------------------------

.get_comment_value:

	push	rsi
	push	rdi
	push	rbx

	lea	rdi, [text_buff_temp]
	mov	rbx, (sizeof.text_buff_temp)
	add	rbx, rdi
	dec	rbx

	mov	rdx, [config_tabsize1]
	add	rdx, rdi
	mov	[tab_pos1], rdx
	mov	rdx, [config_tabsize2]
	add	rdx, rdi
	mov	[tab_pos2], rdx
	mov	rdx, [config_tabsize3]
	add	rdx, rdi
	mov	[tab_pos3], rdx
	mov	rdx, [config_tabsize4]
	add	rdx, rdi
	mov	[tab_pos4], rdx
	mov	rdx, [config_tabsize5]
	add	rdx, rdi
	mov	[tab_pos5], rdx

	mov	rsi, [position_line_in_source]
	test	rsi, rsi
	jz	.gcv_eol

	mov	rcx, [MemSrcFile]
	add	rcx, [SizeSrcFile]

	xor	ah, ah
	mov	dl, byte [config_remove_spaces]


.gcv_loop:
	cmp	rsi, rcx ; ESI = current position_line_in_source, ECX = end position SrcFile
	jae	.gcv_eol
	cmp	rdi, rbx ; EDI = output buffer, EBX = MAX_COMMENT_SIZE (address end of buffer)
	jae	.gcv_eol
	
	mov	ah, al
	lodsb
	cmp	al, 0x0D
	je	.gcv_eol
	cmp	al, 0x0A
	je	.gcv_eol
	test	al, al
	jz	.gcv_eol

	; remove spaces
	test	dl, dl
	jz	.gvc_rs1
	cmp	al, 0x09 ; Tab
	jne	@f
	mov	al, 0x20
	@@:
	cmp	al, 0x20
	jne	.gvc_rs1
	cmp	al, ah
	je	.gcv_loop
	.gvc_rs1:

	; unpack tabs to space
	cmp	al, 0x09 ; Tab
	jne	.gvc_t1
	cmp	rdi, [tab_pos5]
	jae	.gvc_tab6
	cmp	rdi, [tab_pos4]
	jae	.gvc_tab5
	cmp	rdi, [tab_pos3]
	jae	.gvc_tab4
	cmp	rdi, [tab_pos2]
	jae	.gvc_tab3
	cmp	rdi, [tab_pos1]
	jae	.gvc_tab2

	push	rcx
	mov	rcx, [tab_pos1]
	sub	rcx, rdi
	mov	al, 0x20
	rep	stosb
	pop	rcx
	jmp	.gcv_loop
	.gvc_tab2:
	push	rcx
	mov	rcx, [tab_pos2]
	sub	rcx, rdi
	mov	al, 0x20
	rep	stosb
	pop	rcx
	jmp	.gcv_loop
	.gvc_tab3:
	push	rcx
	mov	rcx, [tab_pos3]
	sub	rcx, rdi
	mov	al, 0x20
	rep	stosb
	pop	rcx
	jmp	.gcv_loop
	.gvc_tab4:
	push	rcx
	mov	rcx, [tab_pos4]
	sub	rcx, rdi
	mov	al, 0x20
	rep	stosb
	pop	rcx
	jmp	.gcv_loop
	.gvc_tab5:
	push	rcx
	mov	rcx, [tab_pos5]
	sub	rcx, rdi
	mov	al, 0x20
	rep	stosb
	pop	rcx
	jmp	.gcv_loop
	.gvc_tab6:
	mov	al, 0x20
	.gvc_t1:
	;---

	stosb
	jmp	.gcv_loop

.gcv_eol:
	xor	al, al
	stosb

	;-----------------------------------------------------
	; Append labels before source line (in comment fields)
	cmp	[config_append_labels], 0
	je	.skip_add_label
	mov	dword [buffer_label], 0
	lea	r8, [buffer_label]
	cinvoke	DbgGetLabelAt, [AddrInfo_address], SEG_DEFAULT, r8
	test	rax, rax
	jz	.skip_add_label
	cmp	byte [buffer_label], 0
	je	.skip_add_label

	lea	rsi, [buffer_label]
	lea	rdi, [buffer_comment]
	mov	rbx, rdi
	cld
	mov	rcx, MAX_COMMENT_SIZE-MAX_LABEL_SIZE

	; is local label?
.loop1:
	lodsb
	test	al, al
	jz	.no_loc_label
	dec	rcx
	js	.no_loc_label
	cmp	al, 0x2E ; "." - separator for local label
	jne	.loop1
	dec	rsi
	inc	rcx
	jmp	.loop2

.no_loc_label:
	lea	rsi, [buffer_label]
	mov	rcx, MAX_COMMENT_SIZE-MAX_LABEL_SIZE

.loop2:
	lodsb
	test	al, al
	jz	.eol_label
	dec	rcx
	js	.eol_label
	stosb
	jmp	.loop2
.eol_label:
	mov	ax, 0x203A ; ": "
	stosw
	
	mov	rcx, rdi
	sub	rcx, rbx ; result = length of label
	mov	rbx, rcx

	; skip leading spaces
	lea	rsi, [text_buff_temp]
.loop3:	cmp	byte [rsi], 0x20
	jne	.eol_offset_comment
	inc	rsi
	loop	.loop3
.eol_offset_comment:

	mov	r9, MAX_COMMENT_SIZE
	sub	r9, rbx ; max_size = MAX_COMMENT_SIZE - (size of current label) 

	stdcall	convert_8bit_to_utf8, rsi, -1, rdi, r9 ; .in_text, .in_size, .out_text, .out_max_size
	jmp	.s4


.skip_add_label:
	;-----------------------------------------------------


	lea	rdi, [buffer_comment]
	lea	rcx, [text_buff_temp]
	stdcall	convert_8bit_to_utf8, rcx, -1, rdi, MAX_COMMENT_SIZE ; .in_text, .in_size, .out_text, .out_max_size
.s4:	test	rax, rax
	jnz	@f
	mov	[flag_skip_export_TEXT], 1
	@@:

	
	pop	rbx
	pop	rdi
	pop	rsi
	retn

endp



proc prepare_asmdumps_offsets

	push	rbx
	push	rsi
	push	rdi
	push	r12 ; stack align

	mov	rbx, [pFasFile]
	mov	rsi, [address_assembly_dump]
	lea	rdi, [rsi-4]
	mov	r8d, [rbx+fheader.length_assembly_dump] ; RBX=MemFasFile
	add	rdi, r8
	
	; RSI = Start of assembly dump, RDI =  End of assembly dump (last DWORD in asm dump = size of exe-file).

.main_loop:
	cmp	rsi, rdi
	jae	.end_loop

	mov	edx, [rsi+assembly_dump.offset_of_line_in_source]
	add	rdx, [address_preprocessed_source]
	; RDX = real addr line in preprocessed source.

.loop_skip_macro:
	test	byte [rdx+preprocessed_line.number_line+3], 0x80 ; tab3: +7 = If the highest bit is zeroed, this line was loaded from source. If the highest bit is set, this line was generated by macroinstruction.
	jz	.set_source_addr ; this line was loaded from source
	; this line was generated by macroinstruction
	mov	edx, [rdx+preprocessed_line.offset_prep_line] ; If line was generated by macroinstruction, this field contains the offset of preprocessed line, which invoked the macroinstruction.
	add	rdx, [address_preprocessed_source]
	jmp	.loop_skip_macro ; loop - skip macroinstruction line

.set_source_addr: ; EDX = real addr line in preprocessed source.
	cmp	[rdx+preprocessed_line.offset_prep_line_in_macro_def], 0 ; If the line was generated by macroinstruction, this field contains offset of the preprocessed line inside the definition of macro, from which this one was generated.
	jne	.continue_loop

	mov	r8, rsi
	sub	r8, [address_assembly_dump]
	mov	[rdx+preprocessed_line.offset_prep_line_in_macro_def], r8d  ; RSI = current real addr of asm dump
	; differences in 32 and 64 plugin versions: 32 - store real addr, 64 - store offset (it is not possible to put the QWORD address in DWORD)

.continue_loop: ; RSI = current addr of asm dump
	add	rsi, sizeof.assembly_dump ; skip item, goto next item
	jmp	.main_loop
.end_loop:

	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	xor	rax, rax
	inc	rax
	ret

endp


proc get_next_preprocessed_source_item, .current_addr
; in = real addr of preprocessed source
; do not use ECX, EDX
	push	rsi
	mov	rsi, rcx ; mov rsi, [.current_addr]
	add	rsi, 0x10 ; Table 3 Preprocessed line, +0x10 = The tokenized contents of line.
	cld

.m3:
	lodsb
	cmp	al, 0x1A
	je	.m1
	cmp	al, 0x3B
	je	.m1
	cmp	al, 0x22
	je	.m2
	test	al, al
	jnz	.m3
	mov	rax, rsi
	pop	rsi
	ret

.m1:
	lodsb
	movzx	eax, al
	add	rsi, rax
	jmp	.m3

.m2:
	lodsd
	add	rsi, rax
	jmp	.m3

endp

