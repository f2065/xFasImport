




proc import_sources_to_comments
locals
 filename_src_compare rd 1
 MemSrcFile rd 1
 SizeSrcFile rd 1
 prev_assembly_dump_item rd 1
 position_line_in_source rd 1
 flag_skip_export_TEXT rd 1
 AddrInfo_address rd 1
 buffer_comment sized db MAX_COMMENT_SIZE+8 dup (?)
 buffer_comment_esc sized db MAX_COMMENT_SIZE+8 dup (?)
 buffer_label sized db MAX_LABEL_SIZE+8 dup (?)
 text_buff_temp sized dw MAX_COMMENT_SIZE+500 dup (?)
 tab_pos1 rd 1
 tab_pos2 rd 1
 tab_pos3 rd 1
 tab_pos4 rd 1
 tab_pos5 rd 1
endl

	push	esi
	push	edi
	push	ebx


	xor	eax, eax
	mov	[filename_src_compare], eax
	mov	[prev_assembly_dump_item], eax
	mov	[MemSrcFile], eax
	mov	[SizeSrcFile], eax

	mov	esi, [address_preprocessed_source]

	; ESI - real address of preprocessed source.

.main_loop:
	mov	[flag_skip_export_TEXT], 0
	cmp	esi, [endOf_preprocessed_source] ; ESI = real addr of preprocessed source.
	jae	.end_main_loop

	test	byte [esi+preprocessed_line.number_line+3], 0x80 ; If bit31=0 = line was loaded from source, If bit31=1 = line was generated by macroinstruction.
	jnz	.skip_line ; line by macroinstruction

	mov	ebx, [esi+preprocessed_line.offset_prep_line_in_macro_def] ; !!! current real addr of asm dump !!! stored in prepare_asmdumps_offsets
	test	ebx, ebx
	jz	.skip_line2
	; differences in 32 and 64 plugin versions: 32 - store real addr, 64 - store offset (it is not possible to put the QWORD address in DWORD)


	test	byte [ebx+assembly_dump.flags], 3
	; b0 set = then at this point the assembly was taking place inside the virtual block, and the offset in output file has no meaning here.
	; b1 set = the line was assembled at the point, which was not included in the output file for some other reasons (like inside the reserved data at the end of section).
	jnz	.skip_line2

	push	esi ; ESI = real addr of preprocessed source.
	mov	edx, [esi+preprocessed_line.offset_file_name]
	mov	ecx, [esi+preprocessed_line.number_line]

.loop_skip_dublicate1: ; ESI = real addr of preprocessed source
	stdcall	get_next_preprocessed_source_item, esi ; save ecx, edx for cmp
	mov	esi, eax
	cmp	esi, [endOf_preprocessed_source]
	jae	.end_loop1

	cmp	edx, [esi+preprocessed_line.offset_file_name] ; cmp with the previous item
	jne	.different_file
	cmp	ecx, [esi+preprocessed_line.number_line]
	jz	.loop_skip_dublicate1
.different_file:
	test	byte [esi+preprocessed_line.number_line+3], 0x80 ; If highest bit 0 = line loaded from source. If highest bit 1 = line generated by macroinstruction.
	jnz	.loop_skip_dublicate1 ; JMP - line by macroinstruction

	mov	eax, [esi+preprocessed_line.offset_prep_line_in_macro_def] ; !!! current real addr of asm dump !!! stored in prepare_asmdumps_offsets
	test	eax, eax
	jz	.loop_skip_dublicate1
	; differences in 32 and 64 plugin versions: 32 - store real addr, 64 - store offset (it is not possible to put the QWORD address in DWORD)


	test	byte [eax+assembly_dump.flags], 3
	; b0 set = then at this point the assembly was taking place inside the virtual block, and the offset in output file has no meaning here.
	; b1 set = the line was assembled at the point, which was not included in the output file for some other reasons (like inside the reserved data at the end of section).
	jnz	.loop_skip_dublicate1

	mov	eax, [eax] ; result: EAX =  tab4 [+0] Offset in output file.
	jmp	.exit_loop1

.end_loop1:
	mov	eax, [size_exe_by_fas]

.exit_loop1:
	pop	esi ; pop ESI = real addr of preprocessed source (current item).
	mov	edx, [ebx] ; EBX = current real addr of asm dump, EDX = +0 | dword | Offset in output file.
	sub	eax, edx
	jbe	.skip_line2

;ESI = real addr of preprocessed source (current item).
;EBX = current offset (real addr) of asm dump

	call	.get_address_value
	jmp	.part2

.skip_line2:
	mov	[flag_skip_export_TEXT], 1


.part2:
	mov	edx, [esi+preprocessed_line.offset_file_name]
	; Table 3  Preprocessed line
	; +0 (dword) When the line was loaded from source, this field contains either zero (if it is the line from the main input file),
	; or an offset inside the preprocessed source to the name of file, from which this line was loaded (the name of file is zero-ended string).
	; When the line was generated by macroinstruction, this field contains offset inside the preprocessed source to the pascal-style string specifying
	; the name of macroinstruction, which generated this line.
	test	edx, edx
	jz	.load_main_srcfile
	add	edx, [address_preprocessed_source]
	jmp	.cmp_already_loaded
.load_main_srcfile:
	mov	edx, [address_input_file_name]
.cmp_already_loaded:
	cmp	edx, [filename_src_compare]
	je	.skip_load_file ; this file has already been loaded

	mov	[filename_src_compare], edx ; store for comparison in next lines

	mov	ecx, [MemSrcFile]
	test	ecx, ecx
	jz	@f
	invoke	LocalFree, ecx
	mov	[MemSrcFile], 0
	@@:

	stdcall	load_basepath_fileA_to_mem, [filename_src_compare] ; return - eax hMemory, edx size, ecx timecode. eax=0 - error
	test	eax, eax
	jz	.sstc_exit
	mov	[MemSrcFile], eax
	mov	[SizeSrcFile], edx

	mov	eax, [timeFasFile] ; ASM-file must be written before FAS-file.
	cmp	eax, ecx
	jae	.time_ok
	or	[incorrect_time_flag], 2
	.time_ok:

.skip_load_file:


	mov	eax, [MemSrcFile]

	add	eax, [esi+preprocessed_line.position_file]
	; table3: +8 = If the line was loaded from source, this field contains the position of the line inside the source file, from which it was loaded.
	; If line was generated by macroinstruction, this field contains the offset of preprocessed line, which invoked the macroinstruction.
	; If line was generated by instantaneous macro, this field is equal to the next one.
	mov	[position_line_in_source], eax

	cmp	[flag_skip_export_TEXT], 0
	jnz	.skip_line

	call	.get_comment_value
	cmp	[flag_skip_export_TEXT], 0
	jnz	.skip_line
	lea	ecx, [buffer_comment]
	lea	edx, [buffer_comment_esc]
	stdcall	escaping_string_utf8, ecx, edx, MAX_COMMENT_SIZE ; .in_text, .out_text, .out_max_size
	lea	edx, [buffer_comment_esc]
	cmp	[config_flag_comments_manual], 0
	je	.setA
	cinvoke	DbgSetCommentAt, [AddrInfo_address], edx
	jmp	.setZ
.setA:	cinvoke	DbgSetAutoCommentAt, [AddrInfo_address], edx
.setZ:
	inc	[imported_comments_counter]


;
.skip_line: ; ESI = real addr of preprocessed source
	mov	edx, [esi+preprocessed_line.offset_file_name]
	mov	ecx, [esi+preprocessed_line.number_line]

.loop_skip_dublicate2: ; ESI = real addr of preprocessed source
	stdcall	get_next_preprocessed_source_item, esi
	mov	esi, eax
	cmp	edx, [esi+preprocessed_line.offset_file_name]
	jne	.main_loop
	cmp	ecx, [esi+preprocessed_line.number_line]
	jne	.main_loop
	jmp	.loop_skip_dublicate2



.end_main_loop:


	lea	esi, [text_buff_temp]
	cinvoke	wnsprintfW, esi, (sizeof.text_buff_temp)/2, [msg_comments_loaded_U], [imported_comments_counter]
	stdcall	LogPrintW, esi


	xor	eax, eax
	inc	eax
.sstc_exit:

	pop	ebx
	pop	edi
	pop	esi
	ret




;---------------------------------

; ret: EAX = addr, flag_skip_export_TEXT=1 if skip
.get_address_value:

	mov	eax, [esi+preprocessed_line.offset_prep_line_in_macro_def] ; !!! current real addr of asm dump !!! stored in prepare_asmdumps_offsets
	test	eax, eax ; eax = Table 4 Row of the assembly dump
	jz	.gav_skip
	; differences in 32 and 64 plugin versions: 32 - store real addr, 64 - store offset (it is not possible to put the QWORD address in DWORD)


	cmp	[prev_assembly_dump_item], 0
	jz	.gav_first_item

	push	esi
	push	edi
	cld
	lea	esi, [eax+assembly_dump.address] ; +8 (qword) Value of $ address.
	mov	edi, [prev_assembly_dump_item]
	mov	ecx, 0x11 ; compare bytes: 8-24 (last byte +24 - Type of $ address value)
	repe	cmpsb
	pop	edi
	pop	esi
	je	.gav_skip ; JMP if [esi]==[edi]

.gav_first_item: ; !!! ESI+0x0C = current offset (real addr) of asm dump
	mov	ebx, [esi+preprocessed_line.offset_prep_line_in_macro_def] ; !!! current real addr of asm dump !!! stored in prepare_asmdumps_offsets
	; differences in 32 and 64 plugin versions: 32 - store real addr, 64 - store offset (it is not possible to put the QWORD address in DWORD)

	cmp	dword [ebx+assembly_dump.address], 0 ; +8 (qword) Value of $ address.
	je	.gav_skip
	cmp	dword [ebx+assembly_dump.address+4], 0 ; +8 (qword) Value of $ address.
	jne	.gav_skip ; only for 32-bit plugin
	cmp	byte [ebx+assembly_dump.address_higher_bits], 0 ; tab4  +27 (byte) The higher bits of value of $ address.
	jnz	.gav_skip

	lea	eax, [ebx+assembly_dump.address]
	mov	[prev_assembly_dump_item], eax

	mov	edx, [ebx+assembly_dump.info_external_symbol]
	; If the $ address is relocatable, this field contains information about section or external symbol, to which it is relative - otherwise this field is zero.
	; When the highest bit is cleared, the address is relative to a section, and the bits 0-30 contain the index (starting from 1) in the table of sections.
	; When the highest bit is set, the address is relativeto an external symbol, and the bits 0-30 contain the the offset of the name of this symbol in the strings table.
	test	edx, edx
	jnz	.gav_skip

	cmp	dword [ebx+assembly_dump.sib], 0 ; Extended SIB for the $ address
	jnz	.gav_skip

	mov	edx, dword [ebx+assembly_dump.address]
	sub	edx, [original_base_addr]
	add	edx, [current_base_addr]
	mov	[AddrInfo_address], edx

	retn

.gav_skip:
	mov	[flag_skip_export_TEXT], 1
	retn


;----------------------------------------------------

.get_comment_value:

	push	esi
	push	edi
	push	ebx

	lea	edi, [text_buff_temp]
	mov	ebx, (sizeof.text_buff_temp)
	add	ebx, edi
	dec	ebx

	mov	edx, [config_tabsize1]
	add	edx, edi
	mov	[tab_pos1], edx
	mov	edx, [config_tabsize2]
	add	edx, edi
	mov	[tab_pos2], edx
	mov	edx, [config_tabsize3]
	add	edx, edi
	mov	[tab_pos3], edx
	mov	edx, [config_tabsize4]
	add	edx, edi
	mov	[tab_pos4], edx
	mov	edx, [config_tabsize5]
	add	edx, edi
	mov	[tab_pos5], edx

	mov	esi, [position_line_in_source]
	test	esi, esi
	jz	.gcv_eol

	mov	ecx, [MemSrcFile]
	add	ecx, [SizeSrcFile]

	xor	ah, ah
	mov	dl, byte [config_remove_spaces]


.gcv_loop:
	cmp	esi, ecx ; ESI = current position_line_in_source, ECX = end position SrcFile
	jae	.gcv_eol
	cmp	edi, ebx ; EDI = output buffer, EBX = MAX_COMMENT_SIZE (address end of buffer)
	jae	.gcv_eol

	mov	ah, al
	lodsb
	cmp	al, 0x0D
	je	.gcv_eol
	cmp	al, 0x0A
	je	.gcv_eol
	test	al, al
	jz	.gcv_eol

	; remove spaces
	test	dl, dl
	jz	.gvc_rs1
	cmp	al, 0x09 ; Tab
	jne	@f
	mov	al, 0x20
	@@:
	cmp	al, 0x20
	jne	.gvc_rs1
	cmp	al, ah
	je	.gcv_loop
	.gvc_rs1:

	; unpack tabs to space
	cmp	al, 0x09 ; Tab
	jne	.gvc_t1
	cmp	edi, [tab_pos5]
	jae	.gvc_tab6
	cmp	edi, [tab_pos4]
	jae	.gvc_tab5
	cmp	edi, [tab_pos3]
	jae	.gvc_tab4
	cmp	edi, [tab_pos2]
	jae	.gvc_tab3
	cmp	edi, [tab_pos1]
	jae	.gvc_tab2

	push	ecx
	mov	ecx, [tab_pos1]
	sub	ecx, edi
	mov	al, 0x20
	rep	stosb
	pop	ecx
	jmp	.gcv_loop
	.gvc_tab2:
	push	ecx
	mov	ecx, [tab_pos2]
	sub	ecx, edi
	mov	al, 0x20
	rep	stosb
	pop	ecx
	jmp	.gcv_loop
	.gvc_tab3:
	push	ecx
	mov	ecx, [tab_pos3]
	sub	ecx, edi
	mov	al, 0x20
	rep	stosb
	pop	ecx
	jmp	.gcv_loop
	.gvc_tab4:
	push	ecx
	mov	ecx, [tab_pos4]
	sub	ecx, edi
	mov	al, 0x20
	rep	stosb
	pop	ecx
	jmp	.gcv_loop
	.gvc_tab5:
	push	ecx
	mov	ecx, [tab_pos5]
	sub	ecx, edi
	mov	al, 0x20
	rep	stosb
	pop	ecx
	jmp	.gcv_loop
	.gvc_tab6:
	mov	al, 0x20
	.gvc_t1:
	;---

	stosb
	jmp	.gcv_loop

.gcv_eol:
	xor	al, al
	stosb

	;-----------------------------------------------------
	; Append labels before source line (in comment fields)
	cmp	[config_append_labels], 0
	je	.skip_add_label
	mov	dword [buffer_label], 0
	lea	edx, [buffer_label]
	cinvoke	DbgGetLabelAt, [AddrInfo_address], SEG_DEFAULT, edx
	test	eax, eax
	jz	.skip_add_label
	cmp	byte [buffer_label], 0
	je	.skip_add_label

	lea	esi, [buffer_label]
	lea	edi, [buffer_comment]
	mov	ebx, edi
	cld
	mov	ecx, MAX_COMMENT_SIZE-MAX_LABEL_SIZE

	; is local label?
.loop1:
	lodsb
	test	al, al
	jz	.no_loc_label
	dec	ecx
	js	.no_loc_label
	cmp	al, 0x2E ; "." - separator for local label
	jne	.loop1
	dec	esi
	inc	ecx
	jmp	.loop2

.no_loc_label:
	lea	esi, [buffer_label]
	mov	ecx, MAX_COMMENT_SIZE-MAX_LABEL_SIZE

.loop2:
	lodsb
	test	al, al
	jz	.eol_label
	dec	ecx
	js	.eol_label
	stosb
	jmp	.loop2
.eol_label:
	mov	ax, 0x203A ; ": "
	stosw

	mov	ecx, edi
	sub	ecx, ebx ; result = length of label
	mov	ebx, ecx

	; skip leading spaces
	lea	esi, [text_buff_temp]
.loop3:	cmp	byte [esi], 0x20
	jne	.eol_offset_comment
	inc	esi
	loop	.loop3
.eol_offset_comment:

	mov	eax, MAX_COMMENT_SIZE
	sub	eax, ebx ; max_size = MAX_COMMENT_SIZE - (size of current label)

	stdcall	convert_8bit_to_utf8, esi, -1, edi, eax ; .in_text, .in_size, .out_text, .out_max_size
	jmp	.s4


.skip_add_label:
	;-----------------------------------------------------


	lea	edi, [buffer_comment]
	lea	ecx, [text_buff_temp]
	stdcall	convert_8bit_to_utf8, ecx, -1, edi, MAX_COMMENT_SIZE ; .in_text, .in_size, .out_text, .out_max_size
.s4:	test	eax, eax
	jnz	@f
	mov	[flag_skip_export_TEXT], 1
	@@:


	pop	ebx
	pop	edi
	pop	esi
	retn

endp



proc prepare_asmdumps_offsets

	push	ebx
	push	esi
	push	edi


	mov	ebx, [pFasFile]
	mov	esi, [address_assembly_dump]
	lea	edi, [esi-4]
	add	edi, [ebx+fheader.length_assembly_dump] ; EBX=MemFasFile


	; ESI = Start of assembly dump, EDI =  End of assembly dump (last DWORD in asm dump = size of exe-file).

.main_loop:
	cmp	esi, edi
	jae	.end_loop

	mov	edx, [esi+assembly_dump.offset_of_line_in_source]
	add	edx, [address_preprocessed_source]
	; EDX = real addr line in preprocessed source.

.loop_skip_macro:
	test	byte [edx+preprocessed_line.number_line+3], 0x80 ; tab3: +7 = If the highest bit is zeroed, this line was loaded from source. If the highest bit is set, this line was generated by macroinstruction.
	jz	.set_source_addr ; this line was loaded from source
	; this line was generated by macroinstruction
	mov	edx, [edx+preprocessed_line.offset_prep_line] ; If line was generated by macroinstruction, this field contains the offset of preprocessed line, which invoked the macroinstruction.
	add	edx, [address_preprocessed_source]
	jmp	.loop_skip_macro ; loop - skip macroinstruction line

.set_source_addr: ; EDX = real addr line in preprocessed source.
	cmp	[edx+preprocessed_line.offset_prep_line_in_macro_def], 0 ; If the line was generated by macroinstruction, this field contains offset of the preprocessed line inside the definition of macro, from which this one was generated.
	jne	.continue_loop

	;mov	r8, rsi
	;sub	r8, [address_assembly_dump]
	mov	[edx+preprocessed_line.offset_prep_line_in_macro_def], esi  ; ESI = current real addr of asm dump
	; differences in 32 and 64 plugin versions: 32 - store real addr, 64 - store offset (it is not possible to put the QWORD address in DWORD)

.continue_loop: ; ESI = current addr of asm dump
	add	esi, sizeof.assembly_dump ; skip item, goto next item
	jmp	.main_loop
.end_loop:


	pop	edi
	pop	esi
	pop	ebx
	xor	eax, eax
	inc	eax
	ret

endp


proc get_next_preprocessed_source_item, .current_addr
; in = real addr of preprocessed source
; do not use ECX, EDX
	push	esi
	mov	esi, [.current_addr]
	add	esi, 0x10 ; Table 3 Preprocessed line, +0x10 = The tokenized contents of line.
	cld

.m3:
	lodsb
	cmp	al, 0x1A
	je	.m1
	cmp	al, 0x3B
	je	.m1
	cmp	al, 0x22
	je	.m2
	test	al, al
	jnz	.m3
	mov	eax, esi
	pop	esi
	ret

.m1:
	lodsb
	movzx	eax, al
	add	esi, eax
	jmp	.m3

.m2:
	lodsd
	add	esi, eax
	jmp	.m3

endp

